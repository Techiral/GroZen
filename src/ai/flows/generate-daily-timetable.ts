
'use server';
/**
 * @fileOverview Generates a daily quest-like timetable based on user's natural language task descriptions and preferences.
 *
 * - generateDailyTimetable - A function that generates a daily timetable.
 * - GenerateDailyTimetableInput - The input type for the function.
 * - GenerateDailyTimetableOutput - The return type for the function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import type { QuestType } from '@/types/wellness';

const GenerateDailyTimetableInputSchema = z.object({
  naturalLanguageTasks: z.string().describe("A natural language description of all tasks, goals, and appointments for the day. The AI should parse this to create individual quests."),
  userContext: z.string().optional().describe("Optional general context from the user, e.g., 'I have school from 8am to 3pm. I prefer to exercise in the late afternoon.'"),
  currentDate: z.string().describe("The current date for which the schedule is being planned, in YYYY-MM-DD format."),
  userName: z.string().optional().describe("User's display name for personalized encouragement."),
});
export type GenerateDailyTimetableInput = z.infer<typeof GenerateDailyTimetableInputSchema>;

const ScheduledQuestSchema = z.object({
  id: z.string().describe("A unique ID for this scheduled quest slot, generated by the AI (e.g., UUID format)."),
  originalTaskId: z.string().default("nlp-generated").describe("Identifier for the source task, can be 'nlp-generated-[unique_suffix]' if parsed from natural language directly."),
  title: z.string().describe("An engaging, quest-like title for the task, created by the AI. e.g., 'Conquer Chapter 5!'."),
  startTime: z.string().describe("Suggested start time in HH:MM (24-hour) format."),
  endTime: z.string().describe("Suggested end time in HH:MM (24-hour) format."),
  questType: z.nativeEnum(['study', 'workout', 'hobby', 'chore', 'wellness', 'creative', 'social', 'break', 'other'] as const).describe("The category/type of the quest, inferred by AI."),
  xp: z.number().describe("Suggested XP (experience points) for completing this quest. Based on estimated duration/importance. Range: 10-100 XP."),
  notes: z.string().optional().describe("Optional brief motivational note or tip from the AI related to this quest."),
});
export type ScheduledQuest = z.infer<typeof ScheduledQuestSchema>;

const BreakSlotSchema = z.object({
  id: z.string().describe("A unique ID for this break slot, generated by the AI (e.g., UUID format)."),
  startTime: z.string().describe("Suggested start time for the break in HH:MM (24-hour) format."),
  endTime: z.string().describe("Suggested end time for the break in HH:MM (24-hour) format."),
  suggestion: z.string().optional().describe("A brief, fun, and rejuvenating break activity suggestion (e.g., 'Quick 5-min stretch', 'Listen to a song', 'Hydrate!')."),
  xp: z.number().optional().default(0).describe("Optional small XP bonus for taking a suggested break activity (e.g., 5-10 XP).")
});
export type BreakSlot = z.infer<typeof BreakSlotSchema>;

const GenerateDailyTimetableOutputSchema = z.object({
  scheduledQuests: z.array(ScheduledQuestSchema).describe("An array of time-blocked quests for the day, ordered chronologically."),
  breaks: z.array(BreakSlotSchema).optional().describe("An array of suggested break slots, ordered chronologically."),
  dailySummaryMessage: z.string().optional().describe("A short, positive, and motivational summary or tip for the planned day from the AI."),
});
export type GenerateDailyTimetableOutput = z.infer<typeof GenerateDailyTimetableOutputSchema>;


export async function generateDailyTimetable(input: GenerateDailyTimetableInput): Promise<GenerateDailyTimetableOutput> {
  return generateDailyTimetableFlow(input);
}

const prompt = ai.definePrompt({
  name: 'generateDailyTimetablePrompt',
  input: {schema: GenerateDailyTimetableInputSchema},
  output: {schema: GenerateDailyTimetableOutputSchema},
  prompt: `You are "GroZen Time-Quest AI", an expert life coach and time management guru for teenagers. Your goal is to take a user's natural language description of their day's tasks and preferences, and turn it into an engaging, motivating, and balanced daily "Quest Schedule".
The user, {{#if userName}}{{userName}}{{else}}your awesome GroZen quester{{/if}}, needs a plan for {{currentDate}}.

User's Description of Today's Tasks:
{{{naturalLanguageTasks}}}

{{#if userContext}}
User's General Preferences/Context (Treat these as high priority constraints):
{{{userContext}}}
{{/if}}

Your Mission - CRITICAL GUIDELINES:
1.  **Parse and Identify Quests:** Carefully analyze 'naturalLanguageTasks'. Identify individual, actionable tasks. If the user lists something like "work on my project," try to break it into manageable, focused quest blocks (e.g., "Project Research Block (1hr)", "Project Outline Session (1.5hr)"). Assign realistic durations. A task like 'share info with sales executive' is likely 15-30 minutes, not 1.5 hours. 'Update app features' could be multiple hours or broken down.
2.  **No Overlaps - STRICTLY ENFORCED:** Generated \`scheduledQuests\` and \`breaks\` MUST NOT overlap in time. Each item must have a distinct start and end time. If a break is suggested, its start time should typically be the end time of a preceding quest, and its end time the start of a subsequent quest, unless there's a planned gap.
3.  **Logical Sequencing & Fixed Events:** If \`userContext\` or \`naturalLanguageTasks\` mentions fixed appointments (e.g., "school 8am-3pm", "meeting at 2pm"), schedule these FIRST. Plan other quests around these fixed blocks. Homework should generally be after school hours.
4.  **Balanced Day & Realistic Pacing:** Avoid scheduling multiple long or high-intensity quests back-to-back. Ensure adequate breaks, especially between demanding activities. Consider typical teen energy levels and meal times.
5.  **Craft Engaging Titles:** For each identified task, create an engaging "Quest Title" (e.g., "Solve Math Problems" -> "Conquer Calculus Mountain!").
6.  **Estimate Time & Schedule (HH:MM 24-hour):** Assign realistic 'startTime' and 'endTime'.
7.  **Assign Quest Types:** For each quest, assign an appropriate 'questType' from: 'study', 'workout', 'hobby', 'chore', 'wellness', 'creative', 'social', 'break', 'other'. Infer from the task. Default to 'other' if truly ambiguous.
8.  **Assign XP:** Estimate XP (10-100) based on duration, perceived effort, and importance.
9.  **Incorporate Breaks Strategically:** Insert short, rejuvenating 'Break Slots' (5-20 minutes) between focus blocks. Provide a fun, simple 'suggestion' and optionally a small 'xp' (5-10). Ensure break timings are logical and do not interrupt focused work.
10. **Generate Unique IDs:** For each 'ScheduledQuest' and 'BreakSlot', generate a unique 'id' (UUID format, e.g., 'q1-abc-123'). 'originalTaskId' for ScheduledQuests from natural language can be 'nlp-generated-[uuid_suffix]'.
11. **Motivational Summary:** Provide a brief, positive 'dailySummaryMessage'.
12. **Strict JSON Output:** Your ENTIRE output MUST be a single, valid JSON object adhering to 'GenerateDailyTimetableOutputSchema'.
    - 'scheduledQuests' and 'breaks' arrays MUST be sorted chronologically by 'startTime'.
    - All 'id' fields must be unique strings.

Example of a Scheduled Quest object:
{ "id": "q1-nlp-gen-abc", "originalTaskId": "nlp-generated-abc", "title": "Master History Chapter 3", "startTime": "10:00", "endTime": "11:30", "questType": "study", "xp": 70, "notes": "Time to dive deep into the past!" }

Example of a Break Slot object:
{ "id": "break1-xyz", "startTime": "11:30", "endTime": "11:45", "suggestion": "Quick stretch & grab some water!", "xp": 5 }

Think critically about task durations and sequencing to make the schedule practical and achievable for a teenager. If the user lists many tasks, prioritize and potentially suggest deferring less critical ones if the day becomes too packed.
`,
});

const generateDailyTimetableFlow = ai.defineFlow(
  {
    name: 'generateDailyTimetableFlow',
    inputSchema: GenerateDailyTimetableInputSchema,
    outputSchema: GenerateDailyTimetableOutputSchema,
  },
  async (input) => {
    try {
      const {output} = await prompt(input);
      if (!output || !Array.isArray(output.scheduledQuests)) {
          console.error('generateDailyTimetableFlow: AI did not return a valid array of scheduledQuests. Output:', output);
          throw new Error('AI did not return a valid daily schedule structure.');
      }
      // Ensure IDs are present, AI should generate them but fallback just in case.
      output.scheduledQuests.forEach(q => { if (!q.id) q.id = `quest-${crypto.randomUUID()}`; });
      if (output.breaks) {
        output.breaks.forEach(b => { if (!b.id) b.id = `break-${crypto.randomUUID()}`; });
      }
      
      return output;
    } catch (error) {
      console.error('generateDailyTimetableFlow: Error during AI call or processing. Input:', input, 'Error:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown AI error during timetable generation.';
      if (errorMessage.toLowerCase().includes('quota') || errorMessage.toLowerCase().includes('limit')) {
        throw new Error('AI request limit reached. Please try again later.');
      }
      if (errorMessage.toLowerCase().includes('safety') || errorMessage.toLowerCase().includes('blocked')) {
        throw new Error('AI could not process the request due to safety settings. Please rephrase your input.');
      }
      throw new Error(`Failed to generate daily timetable: ${errorMessage}`);
    }
  }
);

