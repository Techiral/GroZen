
'use server';
/**
 * @fileOverview Generates a daily quest-like timetable based on user's natural language task descriptions and preferences.
 *
 * - generateDailyTimetable - A function that generates a daily timetable.
 * - GenerateDailyTimetableInput - The input type for the function.
 * - GenerateDailyTimetableOutput - The return type for the function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import type { QuestType } from '@/types/wellness';

const GenerateDailyTimetableInputSchema = z.object({
  naturalLanguageTasks: z.string().describe("A natural language description of all tasks, goals, and appointments for the day. The AI should parse this to create individual quests."),
  userContext: z.string().optional().describe("Optional general context from the user, e.g., 'I have school from 8am to 3pm. I prefer to exercise in the late afternoon.'"),
  currentDate: z.string().describe("The current date for which the schedule is being planned, in YYYY-MM-DD format."),
  userName: z.string().optional().describe("User's display name for personalized encouragement."),
});
export type GenerateDailyTimetableInput = z.infer<typeof GenerateDailyTimetableInputSchema>;

const ScheduledQuestSchema = z.object({
  id: z.string().describe("A unique ID for this scheduled quest slot, generated by the AI (e.g., UUID)."),
  originalTaskId: z.string().default("nlp-generated").describe("Identifier for the source task, can be 'nlp-generated' if parsed from natural language directly."),
  title: z.string().describe("An engaging, quest-like title for the task, created by the AI. e.g., 'Conquer Chapter 5!'."),
  startTime: z.string().describe("Suggested start time in HH:MM (24-hour) format."),
  endTime: z.string().describe("Suggested end time in HH:MM (24-hour) format."),
  questType: z.nativeEnum(['study', 'workout', 'hobby', 'chore', 'wellness', 'creative', 'social', 'break', 'other'] as const).describe("The category/type of the quest, inferred by AI."),
  xp: z.number().describe("Suggested XP (experience points) for completing this quest. Based on estimated duration/importance. Range: 10-100 XP."),
  notes: z.string().optional().describe("Optional brief motivational note or tip from the AI related to this quest."),
});
export type ScheduledQuest = z.infer<typeof ScheduledQuestSchema>;

const BreakSlotSchema = z.object({
  id: z.string().describe("A unique ID for this break slot, generated by the AI (e.g., UUID)."),
  startTime: z.string().describe("Suggested start time for the break in HH:MM (24-hour) format."),
  endTime: z.string().describe("Suggested end time for the break in HH:MM (24-hour) format."),
  suggestion: z.string().optional().describe("A brief, fun, and rejuvenating break activity suggestion (e.g., 'Quick 5-min stretch', 'Listen to a song', 'Hydrate!')."),
  xp: z.number().optional().default(0).describe("Optional small XP bonus for taking a suggested break activity (e.g., 5-10 XP).")
});
export type BreakSlot = z.infer<typeof BreakSlotSchema>;

const GenerateDailyTimetableOutputSchema = z.object({
  scheduledQuests: z.array(ScheduledQuestSchema).describe("An array of time-blocked quests for the day, ordered chronologically."),
  breaks: z.array(BreakSlotSchema).optional().describe("An array of suggested break slots, ordered chronologically."),
  dailySummaryMessage: z.string().optional().describe("A short, positive, and motivational summary or tip for the planned day from the AI."),
});
export type GenerateDailyTimetableOutput = z.infer<typeof GenerateDailyTimetableOutputSchema>;


export async function generateDailyTimetable(input: GenerateDailyTimetableInput): Promise<GenerateDailyTimetableOutput> {
  return generateDailyTimetableFlow(input);
}

const prompt = ai.definePrompt({
  name: 'generateDailyTimetablePrompt',
  input: {schema: GenerateDailyTimetableInputSchema},
  output: {schema: GenerateDailyTimetableOutputSchema},
  prompt: `You are "GroZen Time-Quest AI", an expert life coach and time management guru for teenagers. Your goal is to take a user's natural language description of their day's tasks and preferences, and turn it into an engaging, motivating, and balanced daily "Quest Schedule".
The user, {{#if userName}}{{userName}}{{else}}your awesome GroZen quester{{/if}}, needs a plan for {{currentDate}}.

User's Description of Today's Tasks:
{{{naturalLanguageTasks}}}

{{#if userContext}}
User's General Preferences/Context:
{{{userContext}}}
{{/if}}

Your Mission:
1.  **Parse and Identify Quests:** Carefully analyze the 'naturalLanguageTasks' input. Identify individual, actionable tasks or goals. If the user lists something like "work on my project," try to break it into manageable quest blocks (e.g., "Project Research Block," "Project Outline Session").
2.  **Craft Engaging Titles:** For each identified task, create an engaging "Quest Title" (e.g., "Solve Math Problems" -> "Conquer Calculus Mountain!").
3.  **Estimate Time & Schedule:** Assign realistic 'startTime' and 'endTime' (in HH:MM 24-hour format) for each quest. Consider any time cues in the user's input (e.g., "meeting at 2pm", "workout in the evening"). Ensure tasks are logically sequenced.
4.  **Assign Quest Types:** For each quest, assign an appropriate 'questType' from the allowed enum values: 'study', 'workout', 'hobby', 'chore', 'wellness', 'creative', 'social', 'break', 'other'. Infer this from the task's description. Default to 'other' if unsure.
5.  **Assign XP:** Estimate and assign XP points for each quest. Longer, more important, or more demanding quests should generally get more XP. Range: 10-100 XP per quest.
6.  **Incorporate Breaks:** Strategically insert short, rejuvenating 'Break Slots' (5-15 minutes) between longer focus blocks or demanding quests. Provide a fun, simple 'suggestion' for each break (e.g., "Quick 5-min stretch", "Listen to a song"). Optionally assign a small 'xp' bonus (5-10 XP) for completing a suggested break activity.
7.  **Handle Fixed Times:** If the user mentions specific appointments or fixed-time events, schedule these first.
8.  **Balance the Day:** Ensure the schedule feels manageable and not overwhelming. Avoid back-to-back high-energy quests without breaks. Factor in the 'userContext' for overall preferences.
9.  **Generate Unique IDs:** For each 'ScheduledQuest' and 'BreakSlot', generate a unique 'id' (UUID format preferred). 'originalTaskId' for ScheduledQuests derived from natural language can be set to "nlp-generated-[uuid_suffix]" or similar.
10. **Motivational Summary:** Provide a brief, positive, and motivational 'dailySummaryMessage' at the end.
11. **Strict JSON Output:** Structure your ENTIRE output as a single, valid JSON object that strictly adheres to the 'GenerateDailyTimetableOutputSchema'.
    - 'scheduledQuests' and 'breaks' arrays MUST be sorted chronologically by 'startTime'.
    - All 'id' fields must be unique strings.
    - Ensure all fields in ScheduledQuestSchema and BreakSlotSchema are populated correctly.

Example of a Scheduled Quest object:
{ "id": "q1-nlp-gen-abc", "originalTaskId": "nlp-generated-abc", "title": "Master History Chapter 3", "startTime": "10:00", "endTime": "11:30", "questType": "study", "xp": 70, "notes": "Time to dive deep into the past!" }

Example of a Break Slot object:
{ "id": "break1-xyz", "startTime": "11:30", "endTime": "11:45", "suggestion": "Quick stretch & grab some water!", "xp": 5 }

Tips for Teens:
- Frame tasks positively.
- Encourage a growth mindset.
- Acknowledge their effort.
- Keep notes short and punchy.

Generate the Quest Schedule now based on the user's natural language input.
`,
});

const generateDailyTimetableFlow = ai.defineFlow(
  {
    name: 'generateDailyTimetableFlow',
    inputSchema: GenerateDailyTimetableInputSchema,
    outputSchema: GenerateDailyTimetableOutputSchema,
  },
  async (input) => {
    try {
      const {output} = await prompt(input);
      if (!output || !Array.isArray(output.scheduledQuests)) {
          console.error('generateDailyTimetableFlow: AI did not return a valid array of scheduledQuests. Output:', output);
          throw new Error('AI did not return a valid daily schedule structure.');
      }
      // Ensure IDs are present, AI should generate them but fallback just in case.
      output.scheduledQuests.forEach(q => { if (!q.id) q.id = `quest-${crypto.randomUUID()}`; });
      if (output.breaks) {
        output.breaks.forEach(b => { if (!b.id) b.id = `break-${crypto.randomUUID()}`; });
      }
      
      return output;
    } catch (error) {
      console.error('generateDailyTimetableFlow: Error during AI call or processing. Input:', input, 'Error:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown AI error during timetable generation.';
      // Try to return a more specific error message if possible
      if (errorMessage.toLowerCase().includes('quota') || errorMessage.toLowerCase().includes('limit')) {
        throw new Error('AI request limit reached. Please try again later.');
      }
      if (errorMessage.toLowerCase().includes('safety') || errorMessage.toLowerCase().includes('blocked')) {
        throw new Error('AI could not process the request due to safety settings. Please rephrase your input.');
      }
      throw new Error(`Failed to generate daily timetable: ${errorMessage}`);
    }
  }
);
